
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>trial</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-06-07"><meta name="DC.source" content="trial.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#3">Fixation methods</a></li><li><a href="#4">Saccade methods</a></li><li><a href="#5">ROI features</a></li><li><a href="#6">For all Roi</a></li></ul></div><pre class="codeinput"><span class="keyword">classdef</span> trial &lt; handle
    <span class="comment">% inherited from data. Sets, calculates and plots trial specific data</span>
    <span class="keyword">properties</span>
        parent <span class="comment">% Reference to parent object</span>
        data <span class="comment">%Data_file , extracted from participant's ztrack</span>
        trial_no <span class="comment">% Number of Trial</span>
        trial_fieldname <span class="comment">% Fieldname of Trial in string format</span>
        num_samples <span class="comment">% Number of samples</span>
        index <span class="comment">% Actual index of trial data in the raw data</span>
        sample_time <span class="comment">% Time of each sample, used as index</span>
        trial_time  <span class="comment">% Time of each sample, onset at 0</span>
        x <span class="comment">% Sample X value of the eye movement</span>
        y <span class="comment">% Sample Y value of eye movements</span>
        rho <span class="comment">% Distance parameter of the sample Eye momvemnt in polar form</span>
        theta <span class="comment">% Angle parametger of the sample Eye movement in polar form</span>
        issaccadeorfixation <span class="comment">% Indicates whether each sample is a saccade(1) or fixation (-1) or neither (0)</span>

        <span class="comment">%Fixation features</span>
        fixations = struct()
        <span class="comment">%             fixation_start</span>
        <span class="comment">%             fixation_end</span>
        <span class="comment">%             num_fixations % number of fixations in trial</span>
        <span class="comment">%             fixation_location %location of fixation in cartesian formo</span>
        <span class="comment">%             fixation_duration_variation % variation in the duraiton of fixation</span>
        <span class="comment">%             isfixation % Array indicating whether each sample is part of a fixation</span>

        isfixation  <span class="comment">% Array indicatig whether each sample is part of a fixation</span>

        <span class="comment">%Saccade features</span>
        saccades = struct()
        <span class="comment">%             saccade_start</span>
        <span class="comment">%             saccade_end</span>
        <span class="comment">%             num_saccades % Number of saccades in trial</span>
        <span class="comment">%             saccade_location % Location of Saccades, includes starting points (saccade_location[1:2, :] and end points saccade_location[3:4,:]</span>
        <span class="comment">%             saccade_duration_variation %Variation in saccade durations</span>

        issaccade   <span class="comment">% Array indicatig whether each sample is oart of a saccade</span>

        <span class="comment">% ROIs</span>
        rois = struct()

        <span class="comment">%Conditions</span>
        condition <span class="comment">%Associated condition for the given trial</span>


    <span class="keyword">end</span>

    <span class="keyword">methods</span>
</pre><pre class="codeinput">        <span class="keyword">function</span> obj = trial(participant, trial_no, varargin)
            <span class="comment">% Given a parent data file, the data and a trial number with</span>
            <span class="comment">% optional arguments for start and end time of relevant data</span>
            <span class="comment">% creates a trial object. Also sets the x and y parameter</span>

            <span class="keyword">if</span> nargin == 3
                time = varargin{1};
                start_time = time(1);
                end_time = time(2);
            <span class="keyword">end</span>
            obj.trial_fieldname = [<span class="string">'trial_'</span> int2str(trial_no)];
            obj.trial_no = trial_no;
            obj.parent = participant;
            obj.index = start_time:end_time;

            trial_data = obj.parent.getdata(obj);
            obj.x = trial_data.gx(obj.index);
            obj.y = trial_data.gy(obj.index);
            obj.num_samples = length(obj.x);
            obj.sample_time = trial_data.StartTime + uint32(0:obj.num_samples - 1) * uint32(trial_data.sample_rate);
            obj.trial_time = (obj.sample_time(:) - obj.sample_time(1))';
            obj.rois.single = [];
            obj.rois.combined = [];
        <span class="keyword">end</span>

        <span class="keyword">function</span> animate(obj)
            <span class="comment">% Creates and draws an animation plot for the trial&nbsp;</span>
            h = animatedline(<span class="string">'MaximumNumPoints'</span>,1,<span class="string">'color'</span>, <span class="string">'r'</span>, <span class="string">'marker'</span>,<span class="string">'*'</span>);
            a = tic;
            <span class="keyword">for</span> k = 1:length(obj.x)
                addpoints(h,obj.x(k),obj.y(k));
                b = toc(a);
                <span class="keyword">if</span> b &gt; 0.001
                    drawnow
                    a = tic;
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> get_polar(obj)
            <span class="comment">% sets the polar cordinates for the trial. Saved in the theta</span>
            <span class="comment">% and rho properties</span>
            [obj.theta, obj.rho] = cart2pol(obj.x, obj.y);
        <span class="keyword">end</span>

        <span class="keyword">function</span> set_trial_features(obj,varargin)
            obj.number_of_fixation
            obj.number_of_saccade
            obj.duration_of_fixation
            obj.duration_of_saccade
            obj.location_of_fixation
            obj.location_of_saccade
            obj.amplitude_of_saccade
            obj.deviation_of_duration_of_fixation
            obj.deviation_of_duration_of_saccade
            obj.get_polar
            obj.get_issaccade
            obj.get_isfixation
        <span class="keyword">end</span>
        <span class="comment">% ====== Feature detection methods =======</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in trial (line 59)
            obj.trial_fieldname = ['trial_' int2str(trial_no)];
</pre><h2 id="3">Fixation methods</h2><pre class="codeinput">        <span class="keyword">function</span> number_of_fixation(obj)
            <span class="comment">% sets the number of fixations for the trial</span>
            trial_data = obj.parent.getdata(obj);
            intrial_index = find(ismember(trial_data.Fixations.sttime,obj.index));
            obj.fixations.rawindex = intrial_index;
            obj.fixations.number = length(intrial_index);
            [~,col,~] =  find(obj.index == trial_data.Fixations.sttime(intrial_index));
            obj.fixations.start = obj.trial_time(col);
            [~,col,~] =  find(obj.index == trial_data.Fixations.entime(intrial_index));
            obj.fixations.end = obj.trial_time(col);
        <span class="keyword">end</span>

        <span class="keyword">function</span> duration_of_fixation(obj)
            <span class="keyword">if</span> length(obj.fixations.end) &lt; length(obj.fixations.start)
                obj.fixations.end = [obj.fixations.end , obj.trial_time(end)];
            <span class="keyword">end</span>
            obj.fixations.duration = obj.fixations.end - obj.fixations.start ;
        <span class="keyword">end</span>

        <span class="keyword">function</span> deviation_of_duration_of_fixation(obj)
            <span class="comment">% sets the deviation of saccades  duration for the trial</span>
            <span class="keyword">if</span> isfield(obj.fixations, <span class="string">'duration'</span>)
                duration_of_fixation(obj)
            <span class="keyword">end</span>
            obj.fixations.duration_variation = util.zscore(obj.fixations.duration);
        <span class="keyword">end</span>

        <span class="keyword">function</span> location_of_fixation(obj)
            <span class="comment">% sets the location of fixation for the trial</span>
            trial_data = obj.parent.getdata(obj);
            obj.fixations.average_gazex = trial_data.Fixations.gavx(obj.fixations.rawindex);
            obj.fixations.average_gazey = trial_data.Fixations.gavy(obj.fixations.rawindex);
        <span class="keyword">end</span>

       <span class="keyword">function</span> get_isfixation(obj)
            <span class="comment">% sets the issaccade vector.  Also creates fixation_start,</span>
            <span class="comment">% num_samples and sample_times</span>
            obj.isfixation = zeros(1,obj.num_samples);
            [~,col,~ ] = find(obj.fixations.start' &lt;= obj.trial_time &amp; obj.trial_time &lt;= obj.fixations.end');
            obj.isfixation(col) = 1;
        <span class="keyword">end</span>
</pre><h2 id="4">Saccade methods</h2><pre class="codeinput">        <span class="keyword">function</span> number_of_saccade(obj)
            <span class="comment">% sets the number of saccades for the trial</span>
            trial_data = obj.parent.getdata(obj);
            intrial_index = find(ismember(trial_data.Saccades.sttime,obj.index));
            obj.saccades.rawindex = intrial_index;
            obj.saccades.number = length(intrial_index);
            [~,col,~] =  find(obj.index == trial_data.Saccades.sttime(intrial_index));
            obj.saccades.start = obj.trial_time(col);
            [~,col,~] =  find(obj.index == trial_data.Saccades.entime(intrial_index));
            obj.saccades.end = obj.trial_time(col);
        <span class="keyword">end</span>

        <span class="keyword">function</span> duration_of_saccade(obj)
            <span class="comment">% sets the duraiton of saccades for the trial</span>
            <span class="keyword">if</span> length(obj.saccades.end) &lt; length(obj.saccades.start)
                obj.saccades.end = [obj.saccades.end , obj.trial_time(end)];
            <span class="keyword">end</span>
            obj.saccades.duration = obj.fixations.end - obj.fixations.start ;
        <span class="keyword">end</span>

        <span class="keyword">function</span> deviation_of_duration_of_saccade(obj)
            <span class="comment">% Sets the deviation of duration for saccades for the</span>
            <span class="comment">% saccades</span>
            <span class="keyword">if</span> isfield(obj.saccades, <span class="string">'duration'</span>)
                duration_of_saccade(obj)
            <span class="keyword">end</span>

            obj.saccades.duration_variation = util.zscore(double(obj.saccades.duration));
        <span class="keyword">end</span>

        <span class="keyword">function</span> location_of_saccade(obj)
            <span class="comment">% sets the location of saccades points  for the trial</span>
            trial_data = obj.parent.getdata(obj);
            obj.saccades.start_gazex = trial_data.Saccades.gstx(obj.saccades.rawindex);
            obj.saccades.start_gazey = trial_data.Saccades.gsty(obj.saccades.rawindex);
            obj.saccades.end_gazex = trial_data.Saccades.genx(obj.saccades.rawindex);
            obj.saccades.end_gazey = trial_data.Saccades.geny(obj.saccades.rawindex);
        <span class="keyword">end</span>

        <span class="keyword">function</span> amplitude_of_saccade(obj)
            <span class="comment">% sets the amplitude of saccades for the trial</span>
            trial_data = obj.parent.getdata(obj);
            obj.saccades.amplitude =  trial_data.Saccades.ampl(obj.saccades.rawindex);
        <span class="keyword">end</span>

        <span class="keyword">function</span> get_issaccade(obj)
            <span class="comment">% sets the issaccade vector.</span>
            obj.issaccade = zeros(1,obj.num_samples);
            [~,col,~ ] = find(obj.saccades.start' &lt;= obj.trial_time &amp; obj.trial_time &lt;= obj.saccades.end');
            obj.issaccade(col) = 1;
        <span class="keyword">end</span>
</pre><h2 id="5">ROI features</h2><pre class="codeinput">        <span class="keyword">function</span> obj=makeROIs(obj,pos,varargin)

            p = inputParser;
            p.addParameter(<span class="string">'radius'</span>,50,@isnumeric);
            p.addParameter(<span class="string">'shape'</span>,<span class="string">'circle'</span>,@(x) ismember(x,{<span class="string">'circle'</span>,<span class="string">'circular'</span>,<span class="string">'ellipse'</span>,<span class="string">'elliptical'</span>,<span class="string">'square'</span>,<span class="string">'rectangle'</span>,<span class="string">'userDefined'</span>})); <span class="comment">%zhongxu add 'userDefined'</span>
            p.addParameter(<span class="string">'xradius'</span>,50,@isnumeric);
            p.addParameter(<span class="string">'yradius'</span>,10,@isnumeric);
            p.addParameter(<span class="string">'angle'</span>,0,@(x) min(x)&gt;=0 &amp;&amp; max(x)&lt;= 360);
            p.addParameter(<span class="string">'clear'</span>,0);
            p.addParameter(<span class="string">'userDefinedMask'</span>,{},@iscell);
            p.addParameter(<span class="string">'names'</span>,{},@iscell);
            parse(p,varargin{:});

            <span class="keyword">if</span> p.Results.clear==1
                obj.rois.single = [];
                obj.rois.combined = [];
                num_existingrois = 0;
            <span class="keyword">else</span>
                num_existingrois = length(obj.rois.single);
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(p.Results.names)
                number_of_rois = num_existingrois+1:num_existingrois+size(pos,1);
                names = num2str(number_of_rois(:));
            <span class="keyword">else</span>
                number_of_rois = size(pos,1);
                names = p.Results.names;
            <span class="keyword">end</span>

            <span class="keyword">for</span> roi_number = 1:length(number_of_rois)
</pre><h2 id="6">For all Roi</h2><pre class="codeinput">                obj.rois.single(roi_number).name = names{roi_number};
                obj.rois.single(roi_number).coords = pos(roi_number,:);

                <span class="keyword">switch</span> p.Results.shape
                    <span class="keyword">case</span> <span class="string">'userDefined'</span>
                        obj.rois.single(roi_number).shape = <span class="string">'userdefined'</span>;
                        obj.rois.single(roi_number).mask = p.Results.userDefinedMask{roi_number};

                    <span class="keyword">otherwise</span>

                        obj.rois.single(roi_number).shape = p.Reults.shape(roi_number);
                        obj.rois.single(roi_number).radius = p.Results.radius(roi_number);
                        obj.rois.single(roi_number).xradius = p.Results.xradius(roi_number);
                        obj.rois.single(roi_number).yradius = p.Results.yradius(roi_number);

                        xcenter = floor(obj.parent.screen.dims(1)/2);
                        ycenter = floor(obj.parent.screen.dims(2)/2);


                        [XX, YY] = meshgrid(0:(obj.parent.screen.dims(1)-1),<span class="keyword">...</span>
                            0:(obj.parent.screen.dims(2)-1));


                        <span class="keyword">switch</span> p.Results.shape
                            <span class="keyword">case</span> {<span class="string">'circle'</span>,<span class="string">'circular'</span>}
                                obj.rois.single(roi_number).mask = sqrt(XX-pos(roi_number,1).^2+(YY-pos(roi_number,2).^2))<span class="keyword">...</span>
                                                        &lt;=p.Results.radius;

                            <span class="keyword">case</span> {<span class="string">'ellipse'</span>,<span class="string">'elliptical'</span>}
                                xshift = xpos - xcenter;
                                yshift = ypos - ycenter;

                                <span class="comment">%create an ellipse in the center, then rotate</span>
                                el=((XX-xcenter)/p.Results.xradius).^2+((YY-ycenter)/p.Results.yradius).^2&lt;=1;
                                el=imrotate(el,angles(roi_number),<span class="string">'nearest'</span>,<span class="string">'crop'</span>);

                                <span class="comment">%then shift the image so it's centered over the</span>
                                <span class="comment">%correct point</span>
                                RA = imref2d(size(el)); <span class="comment">%so we keep the same image size</span>
                                tform = affine2d([1 0 0; 0 1 0; xshift yshift 1]);
                                obj.rois.single(roi_number).mask = imwarp(el, tform,<span class="string">'OutputView'</span>,RA);

                            <span class="keyword">case</span> {<span class="string">'square'</span>,<span class="string">'rectangle'</span>}   <span class="comment">% this needs to be checked :)</span>
                                obj.rois.single(roi_number).mask = abs(XX-xpos)&lt;=p.Results.xradius &amp; abs(YY-ypos)&lt;=p.Results.yradius;
                        <span class="keyword">end</span>


                <span class="keyword">end</span>
</pre><pre class="codeinput">            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> obj=combineROIs(obj,RoiIndex)
            <span class="comment">% zhongxu add: specifiy which ROIs need to be combined, not  just combined all</span>
            <span class="comment">% TODO: these line of codes are ugly, need to be simplified.</span>
            <span class="keyword">if</span> nargin ==1
                numrois = length(obj.rois.single);
                RoiIndex=1:numrois;
            <span class="keyword">else</span>
                numrois = length(RoiIndex);

                <span class="keyword">if</span> iscell(RoiIndex)
                    <span class="keyword">if</span> ischar(RoiIndex{1})
                        roitotal = length(obj.rois.single);
                        <span class="keyword">for</span> i = 1:roitotal
                            <span class="keyword">for</span> j = 1:numrois
                                <span class="keyword">if</span> strcmp(obj.rois.single(i).name,RoiIndex{j})
                                    tempind(j)= i;
                                <span class="keyword">end</span>
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                        RoiIndex = tempind;
                    <span class="keyword">else</span>
                        RoiIndex = cell2mat(RoiIndex);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            combined = zeros(size(obj.rois.single(1).mask));

            <span class="keyword">for</span> r = 1:numrois

                combined = combined + obj.rois.single(RoiIndex(r)).mask;

            <span class="keyword">end</span>

            obj.rois.combined = combined;

        <span class="keyword">end</span>

       <span class="keyword">function</span> obj = calcHits(obj,varargin)
            <span class="comment">%wrapper for calcEyehits_ to make it easier to repeat for</span>
            <span class="comment">%fixations and saccades.</span>
            p = inputParser;
            p.addParameter(<span class="string">'rois'</span>,<span class="string">'all'</span>,@(x) iscell(x) || ischar(x));
            parse(p,varargin{:});

            obj = calcEyehits_(obj,<span class="string">'rois'</span>,p.Results.rois,<span class="string">'type'</span>,<span class="string">'fixations'</span>);
            obj = calcEyehits_(obj,<span class="string">'rois'</span>,p.Results.rois,<span class="string">'type'</span>,<span class="string">'saccade_start'</span>);
            obj = calcEyehits_(obj,<span class="string">'rois'</span>,p.Results.rois,<span class="string">'type'</span>,<span class="string">'saccade_end'</span>);

       <span class="keyword">end</span>

        <span class="keyword">function</span> obj= calcEyehits_(obj,varargin)
            <span class="comment">%internal function for calculating whether fixations/saccades</span>
            <span class="comment">%hit a given roi or not.</span>
            p = inputParser;
            p.addParameter(<span class="string">'rois'</span>,<span class="string">'all'</span>,@(x) iscell(x) || ischar(x));
            p.addParameter(<span class="string">'type'</span>,<span class="string">'fixations'</span>,@ischar);
            parse(p,varargin{:});

            <span class="keyword">if</span> ~iscell(p.Results.rois) &amp;&amp; strcmp(p.Results.rois,<span class="string">'all'</span>)
                rois = {obj.rois.single.name};
            <span class="keyword">elseif</span> ~iscell(p.Results.rois)
                rois = {p.Results.rois};
            <span class="keyword">else</span>
                rois = p.Results.rois;
            <span class="keyword">end</span>

            numROIs = length(rois);

            <span class="keyword">for</span> r=1:numROIs

                xres = obj.parent.screen.dims(1);
                yres = obj.parent.screen.dims(2);

                roi_idx = find(ismember({obj.rois.single.name},rois{r}));

                roi_mask = obj.rois.single(roi_idx).mask;

                <span class="comment">%matrix of all coordinates</span>

                <span class="keyword">if</span> strcmpi(p.Results.type,<span class="string">'fixations'</span>)
                    coords = [obj.fixations.average_gazex,obj.fixations.average_gazey];
                <span class="keyword">elseif</span> strcmpi(p.Results.type,<span class="string">'saccade_start'</span>)
                    coords = [obj.saccades.start_gazex,obj.saccades.start_gazey];
                <span class="keyword">elseif</span> strcmpi(p.Results.type,<span class="string">'saccade_end'</span>)
                     coords = [obj.saccades.end_gazex,obj.saccades.end_gazey];
                <span class="keyword">end</span>

                coords = ceil(coords);
                idx = sub2ind([yres,xres],coords(:,2),coords(:,1));
                overlap = ismember(idx, find(roi_mask));

                <span class="keyword">if</span> strcmpi(p.Results.type,<span class="string">'fixations'</span>)
                   obj.fixations.hits = overlap';
                <span class="keyword">elseif</span> strcmpi(p.Results.type,<span class="string">'saccade_start'</span>)
                   obj.saccades.start_hits = overlap';
                <span class="keyword">elseif</span> strcmpi(p.Results.type,<span class="string">'saccade_end'</span>)
                   obj.saccades.end_hits = overlap';
                <span class="keyword">end</span>

            <span class="keyword">end</span>
        <span class="keyword">end</span>
<span class="comment">%</span>
<span class="comment">%         function regionsofinterest(obj)</span>
<span class="comment">%             %doesn't do anything useful =] (yet)</span>
<span class="comment">%             if isempty(obj.fixation_location)</span>
<span class="comment">%                 location_of_fixation(obj)</span>
<span class="comment">%             end</span>
<span class="comment">%             figure</span>
<span class="comment">%             hold on</span>
<span class="comment">%             a = [obj.fixation_location' , kmeans(obj.fixation_location',10)];</span>
<span class="comment">%             for i=1:10</span>
<span class="comment">%                 scatter(a(a(:,3) == i,1), a(a(:,3) == i,2))</span>
<span class="comment">%             end</span>
<span class="comment">%         end</span>

        <span class="keyword">function</span> set_grid(obj, gridsize)
            <span class="comment">%size could either be a vectory or a value for square sized</span>
            xres = obj.parent.screen.dims(1);
            yres = obj.parent.screen.dims(2);
            <span class="keyword">if</span> strcmpi(gridsize, <span class="string">'default'</span>)
                division_factor = gcd(xres,yres);
                gridsize = sqrt(gcd(xres,yres)); <span class="comment">% better way to calculate the default size? eg, gcf of  xres yres</span>
            <span class="keyword">end</span>

           total_grids = xres/ gridsize;
           all_grids = cell(1,total_grids);
           mygrid = zeros(yres,xres);

           xbreaks = [1:gridsize:yres, yres];
           ybreaks = [1:gridsize:xres, xres];

           <span class="keyword">for</span> grid_num = 1:total_grids
               <span class="keyword">for</span> i = 1:length(xbreaks)-1
                   <span class="keyword">for</span> j = 1:length(ybreaks)-1
                       mygrid(xbreaks(i):xbreaks(i+1),ybreaks(j):ybreaks(j+1))  = i;

                   <span class="keyword">end</span>
               <span class="keyword">end</span>
               all_grids(grid_num) = {mygrid};
               mygrid = zeros(yres,xres);
           <span class="keyword">end</span>
           makeROIs(obj,size(mygrid),<span class="string">'shape'</span>,<span class="string">'userDefined'</span>,<span class="string">'userDefinedMask'</span>,  all_grids, <span class="string">'names'</span>, {strcat(<span class="string">'grid_'</span>, num2str(gridsize))})
        <span class="keyword">end</span>

        <span class="keyword">function</span> recurrence(obj, varargin)
            obj.calcHits(<span class="string">'rois'</span>, <span class="string">'grid16'</span>)


        <span class="keyword">end</span>
</pre><pre class="codeinput">      <span class="keyword">end</span>




<span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
classdef trial < handle
    % inherited from data. Sets, calculates and plots trial specific data
    properties
        parent % Reference to parent object
        data %Data_file , extracted from participant's ztrack
        trial_no % Number of Trial
        trial_fieldname % Fieldname of Trial in string format
        num_samples % Number of samples
        index % Actual index of trial data in the raw data
        sample_time % Time of each sample, used as index
        trial_time  % Time of each sample, onset at 0
        x % Sample X value of the eye movement
        y % Sample Y value of eye movements
        rho % Distance parameter of the sample Eye momvemnt in polar form
        theta % Angle parametger of the sample Eye movement in polar form
        issaccadeorfixation % Indicates whether each sample is a saccade(1) or fixation (-1) or neither (0)
        
        %Fixation features
        fixations = struct()
        %             fixation_start
        %             fixation_end
        %             num_fixations % number of fixations in trial
        %             fixation_location %location of fixation in cartesian formo
        %             fixation_duration_variation % variation in the duraiton of fixation
        %             isfixation % Array indicating whether each sample is part of a fixation
        
        isfixation  % Array indicatig whether each sample is part of a fixation
        
        %Saccade features
        saccades = struct()
        %             saccade_start
        %             saccade_end
        %             num_saccades % Number of saccades in trial
        %             saccade_location % Location of Saccades, includes starting points (saccade_location[1:2, :] and end points saccade_location[3:4,:]
        %             saccade_duration_variation %Variation in saccade durations
        
        issaccade   % Array indicatig whether each sample is oart of a saccade
        
        % ROIs
        rois = struct()

        %Conditions
        condition %Associated condition for the given trial
        
        
    end
    
    methods
        function obj = trial(participant, trial_no, varargin)
            % Given a parent data file, the data and a trial number with
            % optional arguments for start and end time of relevant data
            % creates a trial object. Also sets the x and y parameter

            if nargin == 3
                time = varargin{1};
                start_time = time(1);
                end_time = time(2);
            end
            obj.trial_fieldname = ['trial_' int2str(trial_no)];
            obj.trial_no = trial_no;
            obj.parent = participant;
            obj.index = start_time:end_time;
            
            trial_data = obj.parent.getdata(obj);
            obj.x = trial_data.gx(obj.index);
            obj.y = trial_data.gy(obj.index);
            obj.num_samples = length(obj.x);
            obj.sample_time = trial_data.StartTime + uint32(0:obj.num_samples - 1) * uint32(trial_data.sample_rate);
            obj.trial_time = (obj.sample_time(:) - obj.sample_time(1))';
            obj.rois.single = [];
            obj.rois.combined = [];
        end
             
        function animate(obj)
            % Creates and draws an animation plot for the trial 
            h = animatedline('MaximumNumPoints',1,'color', 'r', 'marker','*');
            a = tic;
            for k = 1:length(obj.x)
                addpoints(h,obj.x(k),obj.y(k));
                b = toc(a);
                if b > 0.001
                    drawnow
                    a = tic;
                end
            end
        end
        
        function get_polar(obj)
            % sets the polar cordinates for the trial. Saved in the theta
            % and rho properties
            [obj.theta, obj.rho] = cart2pol(obj.x, obj.y);
        end
        
        function set_trial_features(obj,varargin)
            obj.number_of_fixation
            obj.number_of_saccade
            obj.duration_of_fixation
            obj.duration_of_saccade
            obj.location_of_fixation
            obj.location_of_saccade
            obj.amplitude_of_saccade
            obj.deviation_of_duration_of_fixation
            obj.deviation_of_duration_of_saccade
            obj.get_polar
            obj.get_issaccade
            obj.get_isfixation
        end
        % ====== Feature detection methods =======
        %% Fixation methods
        function number_of_fixation(obj)
            % sets the number of fixations for the trial
            trial_data = obj.parent.getdata(obj);
            intrial_index = find(ismember(trial_data.Fixations.sttime,obj.index));
            obj.fixations.rawindex = intrial_index;
            obj.fixations.number = length(intrial_index);
            [~,col,~] =  find(obj.index == trial_data.Fixations.sttime(intrial_index));
            obj.fixations.start = obj.trial_time(col);
            [~,col,~] =  find(obj.index == trial_data.Fixations.entime(intrial_index));
            obj.fixations.end = obj.trial_time(col);
        end   
        
        function duration_of_fixation(obj)
            if length(obj.fixations.end) < length(obj.fixations.start)
                obj.fixations.end = [obj.fixations.end , obj.trial_time(end)];
            end
            obj.fixations.duration = obj.fixations.end - obj.fixations.start ;
        end
        
        function deviation_of_duration_of_fixation(obj)
            % sets the deviation of saccades  duration for the trial
            if isfield(obj.fixations, 'duration')
                duration_of_fixation(obj)
            end
            obj.fixations.duration_variation = util.zscore(obj.fixations.duration);           
        end
        
        function location_of_fixation(obj)
            % sets the location of fixation for the trial
            trial_data = obj.parent.getdata(obj);
            obj.fixations.average_gazex = trial_data.Fixations.gavx(obj.fixations.rawindex);
            obj.fixations.average_gazey = trial_data.Fixations.gavy(obj.fixations.rawindex);
        end
        
       function get_isfixation(obj)
            % sets the issaccade vector.  Also creates fixation_start,
            % num_samples and sample_times
            obj.isfixation = zeros(1,obj.num_samples);
            [~,col,~ ] = find(obj.fixations.start' <= obj.trial_time & obj.trial_time <= obj.fixations.end');
            obj.isfixation(col) = 1;
        end
        
        %% Saccade methods
        function number_of_saccade(obj)
            % sets the number of saccades for the trial
            trial_data = obj.parent.getdata(obj);
            intrial_index = find(ismember(trial_data.Saccades.sttime,obj.index));
            obj.saccades.rawindex = intrial_index;
            obj.saccades.number = length(intrial_index);
            [~,col,~] =  find(obj.index == trial_data.Saccades.sttime(intrial_index));
            obj.saccades.start = obj.trial_time(col);
            [~,col,~] =  find(obj.index == trial_data.Saccades.entime(intrial_index));
            obj.saccades.end = obj.trial_time(col);
        end
        
        function duration_of_saccade(obj)
            % sets the duraiton of saccades for the trial
            if length(obj.saccades.end) < length(obj.saccades.start)
                obj.saccades.end = [obj.saccades.end , obj.trial_time(end)];
            end
            obj.saccades.duration = obj.fixations.end - obj.fixations.start ;
        end
        
        function deviation_of_duration_of_saccade(obj)
            % Sets the deviation of duration for saccades for the
            % saccades
            if isfield(obj.saccades, 'duration')
                duration_of_saccade(obj)
            end
            
            obj.saccades.duration_variation = util.zscore(double(obj.saccades.duration));
        end
        
        function location_of_saccade(obj)
            % sets the location of saccades points  for the trial
            trial_data = obj.parent.getdata(obj);
            obj.saccades.start_gazex = trial_data.Saccades.gstx(obj.saccades.rawindex);
            obj.saccades.start_gazey = trial_data.Saccades.gsty(obj.saccades.rawindex);
            obj.saccades.end_gazex = trial_data.Saccades.genx(obj.saccades.rawindex);
            obj.saccades.end_gazey = trial_data.Saccades.geny(obj.saccades.rawindex);
        end
            
        function amplitude_of_saccade(obj)
            % sets the amplitude of saccades for the trial
            trial_data = obj.parent.getdata(obj);
            obj.saccades.amplitude =  trial_data.Saccades.ampl(obj.saccades.rawindex);
        end
        
        function get_issaccade(obj)
            % sets the issaccade vector.
            obj.issaccade = zeros(1,obj.num_samples);
            [~,col,~ ] = find(obj.saccades.start' <= obj.trial_time & obj.trial_time <= obj.saccades.end');
            obj.issaccade(col) = 1;
        end
        
        %% ROI features 
        
        function obj=makeROIs(obj,pos,varargin)
            
            p = inputParser;
            p.addParameter('radius',50,@isnumeric);
            p.addParameter('shape','circle',@(x) ismember(x,{'circle','circular','ellipse','elliptical','square','rectangle','userDefined'})); %zhongxu add 'userDefined'
            p.addParameter('xradius',50,@isnumeric);
            p.addParameter('yradius',10,@isnumeric);
            p.addParameter('angle',0,@(x) min(x)>=0 && max(x)<= 360);
            p.addParameter('clear',0);
            p.addParameter('userDefinedMask',{},@iscell);
            p.addParameter('names',{},@iscell);
            parse(p,varargin{:});
            
            if p.Results.clear==1
                obj.rois.single = [];
                obj.rois.combined = [];
                num_existingrois = 0;
            else
                num_existingrois = length(obj.rois.single);
            end
            
            if isempty(p.Results.names)
                number_of_rois = num_existingrois+1:num_existingrois+size(pos,1);
                names = num2str(number_of_rois(:));
            else
                number_of_rois = size(pos,1);
                names = p.Results.names;
            end
            
            for roi_number = 1:length(number_of_rois)
                %% For all Roi
                obj.rois.single(roi_number).name = names{roi_number};
                obj.rois.single(roi_number).coords = pos(roi_number,:);
                
                switch p.Results.shape
                    case 'userDefined'                       
                        obj.rois.single(roi_number).shape = 'userdefined';
                        obj.rois.single(roi_number).mask = p.Results.userDefinedMask{roi_number};
                        
                    otherwise
                        
                        obj.rois.single(roi_number).shape = p.Reults.shape(roi_number);
                        obj.rois.single(roi_number).radius = p.Results.radius(roi_number);
                        obj.rois.single(roi_number).xradius = p.Results.xradius(roi_number);
                        obj.rois.single(roi_number).yradius = p.Results.yradius(roi_number);
                        
                        xcenter = floor(obj.parent.screen.dims(1)/2);
                        ycenter = floor(obj.parent.screen.dims(2)/2);
                        
                        
                        [XX, YY] = meshgrid(0:(obj.parent.screen.dims(1)-1),...
                            0:(obj.parent.screen.dims(2)-1));
                        
                        
                        switch p.Results.shape
                            case {'circle','circular'}
                                obj.rois.single(roi_number).mask = sqrt(XX-pos(roi_number,1).^2+(YY-pos(roi_number,2).^2))...
                                                        <=p.Results.radius;
                                
                            case {'ellipse','elliptical'}
                                xshift = xpos - xcenter;
                                yshift = ypos - ycenter;
                                
                                %create an ellipse in the center, then rotate
                                el=((XX-xcenter)/p.Results.xradius).^2+((YY-ycenter)/p.Results.yradius).^2<=1;
                                el=imrotate(el,angles(roi_number),'nearest','crop');
                                
                                %then shift the image so it's centered over the
                                %correct point
                                RA = imref2d(size(el)); %so we keep the same image size
                                tform = affine2d([1 0 0; 0 1 0; xshift yshift 1]);
                                obj.rois.single(roi_number).mask = imwarp(el, tform,'OutputView',RA);
                                
                            case {'square','rectangle'}   % this needs to be checked :)
                                obj.rois.single(roi_number).mask = abs(XX-xpos)<=p.Results.xradius & abs(YY-ypos)<=p.Results.yradius;
                        end
                        
                        
                end
                
            end
        end
            
        function obj=combineROIs(obj,RoiIndex)
            % zhongxu add: specifiy which ROIs need to be combined, not  just combined all
            % TODO: these line of codes are ugly, need to be simplified.
            if nargin ==1
                numrois = length(obj.rois.single);
                RoiIndex=1:numrois;
            else
                numrois = length(RoiIndex);
                
                if iscell(RoiIndex)
                    if ischar(RoiIndex{1})
                        roitotal = length(obj.rois.single);
                        for i = 1:roitotal
                            for j = 1:numrois
                                if strcmp(obj.rois.single(i).name,RoiIndex{j})
                                    tempind(j)= i;
                                end
                            end
                        end
                        RoiIndex = tempind;
                    else
                        RoiIndex = cell2mat(RoiIndex);
                    end
                end
            end
            
            combined = zeros(size(obj.rois.single(1).mask));
            
            for r = 1:numrois
                
                combined = combined + obj.rois.single(RoiIndex(r)).mask;
                
            end
            
            obj.rois.combined = combined;
            
        end
        
       function obj = calcHits(obj,varargin)
            %wrapper for calcEyehits_ to make it easier to repeat for
            %fixations and saccades.
            p = inputParser;
            p.addParameter('rois','all',@(x) iscell(x) || ischar(x));
            parse(p,varargin{:});
            
            obj = calcEyehits_(obj,'rois',p.Results.rois,'type','fixations');
            obj = calcEyehits_(obj,'rois',p.Results.rois,'type','saccade_start');
            obj = calcEyehits_(obj,'rois',p.Results.rois,'type','saccade_end');
            
       end
        
        function obj= calcEyehits_(obj,varargin)
            %internal function for calculating whether fixations/saccades
            %hit a given roi or not.
            p = inputParser;
            p.addParameter('rois','all',@(x) iscell(x) || ischar(x));
            p.addParameter('type','fixations',@ischar);
            parse(p,varargin{:});
                        
            if ~iscell(p.Results.rois) && strcmp(p.Results.rois,'all')
                rois = {obj.rois.single.name};
            elseif ~iscell(p.Results.rois)
                rois = {p.Results.rois};
            else
                rois = p.Results.rois;
            end
            
            numROIs = length(rois);
            
            for r=1:numROIs

                xres = obj.parent.screen.dims(1);
                yres = obj.parent.screen.dims(2);

                roi_idx = find(ismember({obj.rois.single.name},rois{r}));

                roi_mask = obj.rois.single(roi_idx).mask;

                %matrix of all coordinates
                
                if strcmpi(p.Results.type,'fixations')
                    coords = [obj.fixations.average_gazex,obj.fixations.average_gazey];
                elseif strcmpi(p.Results.type,'saccade_start')
                    coords = [obj.saccades.start_gazex,obj.saccades.start_gazey];                  
                elseif strcmpi(p.Results.type,'saccade_end')
                     coords = [obj.saccades.end_gazex,obj.saccades.end_gazey];                                      
                end
                
                coords = ceil(coords);
                idx = sub2ind([yres,xres],coords(:,2),coords(:,1));
                overlap = ismember(idx, find(roi_mask));
                
                if strcmpi(p.Results.type,'fixations')
                   obj.fixations.hits = overlap';     
                elseif strcmpi(p.Results.type,'saccade_start')
                   obj.saccades.start_hits = overlap';     
                elseif strcmpi(p.Results.type,'saccade_end')
                   obj.saccades.end_hits = overlap';     
                end
                
            end
        end
% 
%         function regionsofinterest(obj)
%             %doesn't do anything useful =] (yet)
%             if isempty(obj.fixation_location)
%                 location_of_fixation(obj)
%             end
%             figure
%             hold on
%             a = [obj.fixation_location' , kmeans(obj.fixation_location',10)];
%             for i=1:10
%                 scatter(a(a(:,3) == i,1), a(a(:,3) == i,2))
%             end
%         end
        
        function set_grid(obj, gridsize)
            %size could either be a vectory or a value for square sized 
            xres = obj.parent.screen.dims(1);
            yres = obj.parent.screen.dims(2);
            if strcmpi(gridsize, 'default')  
                division_factor = gcd(xres,yres);
                gridsize = sqrt(gcd(xres,yres)); % better way to calculate the default size? eg, gcf of  xres yres
            end
           
           total_grids = xres/ gridsize;
           all_grids = cell(1,total_grids);
           mygrid = zeros(yres,xres);
           
           xbreaks = [1:gridsize:yres, yres];
           ybreaks = [1:gridsize:xres, xres];
           
           for grid_num = 1:total_grids
               for i = 1:length(xbreaks)-1
                   for j = 1:length(ybreaks)-1
                       mygrid(xbreaks(i):xbreaks(i+1),ybreaks(j):ybreaks(j+1))  = i;

                   end
               end
               all_grids(grid_num) = {mygrid}; 
               mygrid = zeros(yres,xres);
           end
           makeROIs(obj,size(mygrid),'shape','userDefined','userDefinedMask',  all_grids, 'names', {strcat('grid_', num2str(gridsize))})
        end
        
        function recurrence(obj, varargin)
            obj.calcHits('rois', 'grid16')
        
            
        end
      end
      

        
        
end

##### SOURCE END #####
--></body></html>